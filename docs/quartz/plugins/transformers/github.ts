// modified version of https://github.com/remarkjs/remark-github/blob/main/index.js
// main change: Update mentionRegex to work with rehype-citation
import fs from "node:fs"
import path from "node:path"

import { BuildUrlValues, defaultBuildUrl } from "remark-github"
import { RepositoryInfo, UrlInfo } from "remark-github/lib"
import { Root, Link } from "mdast"
import {
  RegExpMatchObject,
  ReplaceFunction,
  findAndReplace as mdastFindReplace,
} from "mdast-util-find-and-replace"
import { toString } from "mdast-util-to-string"
import { QuartzTransformerPlugin } from "../types"
import { visit } from "unist-util-visit"
import { PhrasingContent } from "mdast-util-find-and-replace/lib"

// Previously, GitHub linked `@mention` and `@mentions` to their blog post about
// mentions (<https://github.com/blog/821>).
// Since June 2019, and possibly earlier, they stopped linking those references.
const denyMention = new Set(["mention", "mentions"])
// Denylist of SHAs that are also valid words.
//
// GitHub allows abbreviating SHAs up to 7 characters.
// These cases are ignored in text because they might just be ment as normal
// words.
// If you‚Äôd like these to link to their SHAs, use more than 7 characters.
//
// Generated by:
//
// ```sh
// egrep -i "^[a-f0-9]{7,}$" /usr/share/dict/words
// ```
//
// Added a couple forms of 6 character words in GH-20:
// <https://github.com/remarkjs/remark-github/issues/20>.
const denyHash = new Set(["acceded", "deedeed", "defaced", "effaced", "fabaceae"])
// Constants.
const minShaLength = 7
// Username may only contain alphanumeric characters or single hyphens, and
// cannot begin or end with a hyphen*.
//
// \* That is: until <https://github.com/remarkjs/remark-github/issues/13>.
const userGroup = "[\\da-z][-\\da-z]{0,38}"
const projectGroup = "(?:\\.git[\\w-]|\\.(?!git)|[\\w-])+"
const repoGroup = "(" + userGroup + ")\\/(" + projectGroup + ")"
const linkRegex = new RegExp(
  "^https?:\\/\\/github\\.com\\/" +
    repoGroup +
    "\\/(commit|compare|issues|pull)\\/([a-f\\d]+(?:\\.{3}[a-f\\d]+)?\\/?(?=[#?]|$))",
  "i",
)
const repoRegex = new RegExp("(?:^|/(?:repos/)?)" + repoGroup + "(?=\\.git|[\\/#@]|$)", "i")
const referenceRegex = new RegExp(
  "(" + userGroup + ")(?:\\/(" + projectGroup + "))?(?:#([1-9]\\d*)|@([a-f\\d]{7,40}))",
  "gi",
)
const mentionRegex = new RegExp("(?<!\\[)@(" + userGroup + "(?:\\/" + userGroup + ")?)", "gi")

function getRepoFromPackage(cwd: string) {
  let pkg

  try {
    pkg = JSON.parse(String(fs.readFileSync(path.join(cwd, "package.json"))))
  } catch {}

  const repository =
    pkg && pkg.repository
      ? // Object form.
        /* c8 ignore next 2 */
        typeof pkg.repository === "object"
        ? pkg.repository.url
        : pkg.repository
      : ""

  return repository
}

export interface Options {
  repository?: string
  buildUrl?: (values: BuildUrlValues) => string
  mentionStrong?: boolean
}

const defaultOptions: Options = {
  repository: "https://github.com/aarnphm/aarnphm.github.io",
  buildUrl: defaultBuildUrl,
  mentionStrong: true,
}

export const GitHub: QuartzTransformerPlugin<Partial<Options>> = (userOpts) => {
  const opts = { ...defaultOptions, ...userOpts }
  const buildUrl = opts.buildUrl || defaultBuildUrl

  return {
    name: "GitHub",
    markdownPlugins() {
      return [
        () => {
          return (tree: Root, file) => {
            const repository = opts.repository || getRepoFromPackage(file.cwd)

            if (!repository) {
              throw new Error("Unexpected missing `repository` in `options`")
            }

            // Parse the URL: See the tests for all possible kinds.
            const repositoryMatch = repoRegex.exec(repository)

            if (!repositoryMatch) {
              throw new Error(
                "Unexpected invalid `repository`, expected for example `user/project`",
              )
            }

            const repositoryInfo: RepositoryInfo = {
              project: repositoryMatch[2],
              user: repositoryMatch[1],
            }
            mdastFindReplace(
              tree,
              [
                [referenceRegex, replaceReference],
                [mentionRegex, replaceMention],
                [/(?:#|\bgh-)([1-9]\d*)/gi, replaceIssue],
                [/\b([a-f\d]{7,40})\.{3}([a-f\d]{7,40})\b/gi, replaceHashRange],
                [/\b[a-f\d]{7,40}\b/gi, replaceHash],
              ],
              { ignore: ["link", "linkReference"] },
            )

            visit(tree, "link", function (node) {
              const link = parse(node)

              if (!link) {
                return
              }

              const comment = link.comment ? " (comment)" : ""
              let base: string

              if (
                link.project !== repositoryInfo.project ||
                // Compare page uses full `user/project` for forks.
                (link.page === "compare" && link.user !== repositoryInfo.user)
              ) {
                base = link.user + "/" + link.project
              } else if (link.user === repositoryInfo.user) {
                base = ""
              } else {
                base = link.user
              }

              const children: PhrasingContent[] = []

              if (link.page === "issues" || link.page === "pull") {
                base += "#"
                children.push({
                  type: "text",
                  value: base + link.reference + comment,
                })
              } else {
                if (base) {
                  children.push({ type: "text", value: base + "@" })
                }

                children.push({ type: "inlineCode", value: link.reference })

                if (link.comment) {
                  children.push({ type: "text", value: comment })
                }
              }

              node.children = children
            })

            /**
             * @type {ReplaceFunction}
             */
            function replaceMention(value: string, username: string, match: RegExpMatchObject) {
              if (match === undefined) return false
              if (
                /[\w`]/.test(match.input.charAt(match.index - 1)) ||
                /[/\w`]/.test(match.input.charAt(match.index + value.length)) ||
                denyMention.has(username)
              ) {
                return false
              }

              const url = buildUrl({ type: "mention", user: username })

              if (!url) return false

              let node: PhrasingContent = { type: "text", value }

              if (opts.mentionStrong !== false) {
                node = { type: "strong", children: [node] }
              }

              return { type: "link", title: null, url, children: [node] }
            }

            /**
             * @type {ReplaceFunction}
             */
            function replaceIssue(value: string, no: string, match: RegExpMatchObject) {
              if (
                /\w/.test(match.input.charAt(match.index - 1)) ||
                /\w/.test(match.input.charAt(match.index + value.length))
              ) {
                return false
              }

              const url = buildUrl({ no, type: "issue", ...repositoryInfo })

              return url
                ? { type: "link", title: null, url, children: [{ type: "text", value }] }
                : false
            }

            /**
             * @type {ReplaceFunction}
             */
            function replaceHashRange(
              value: string,
              a: string,
              b: string,
              match: RegExpMatchObject,
            ) {
              if (
                /[^\t\n\r (@[{]/.test(match.input.charAt(match.index - 1)) ||
                /\w/.test(match.input.charAt(match.index + value.length)) ||
                denyHash.has(value)
              ) {
                return false
              }

              const url = buildUrl({
                base: a,
                compare: b,
                type: "compare",
                ...repositoryInfo,
              })

              return url
                ? {
                    type: "link",
                    title: null,
                    url,
                    children: [{ type: "inlineCode", value: abbr(a) + "..." + abbr(b) }],
                  }
                : false
            }

            /**
             * @type {ReplaceFunction}
             */
            function replaceHash(value: string, match: RegExpMatchObject) {
              if (
                /[^\t\n\r (@[{.]/.test(match.input.charAt(match.index - 1)) ||
                // For some weird reason GH does link two dots, but not one ü§∑‚Äç‚ôÇÔ∏è
                (match.input.charAt(match.index - 1) === "." &&
                  match.input.charAt(match.index - 2) !== ".") ||
                /\w/.test(match.input.charAt(match.index + value.length)) ||
                denyHash.has(value)
              ) {
                return false
              }

              const url = buildUrl({ hash: value, type: "commit", ...repositoryInfo })

              return url
                ? {
                    type: "link",
                    title: null,
                    url,
                    children: [{ type: "inlineCode", value: abbr(value) }],
                  }
                : false
            }

            /**
             * @type {ReplaceFunction}
             */
            function replaceReference(
              $0: string,
              user: string,
              specificProject: string,
              no: string,
              hash: string,
              match: RegExpMatchObject,
            ) {
              if (
                /[^\t\n\r (@[{]/.test(match.input.charAt(match.index - 1)) ||
                /\w/.test(match.input.charAt(match.index + $0.length))
              ) {
                return false
              }

              const project = specificProject || repositoryInfo.project
              const values: BuildUrlValues = no
                ? { no, project, type: "issue", user }
                : { hash, project, type: "commit", user }
              const url = buildUrl(values)

              if (!url) return false

              const nodes: PhrasingContent[] = []
              let value = ""

              if (project !== repositoryInfo.project) {
                value += user + "/" + project
              } else if (user !== repositoryInfo.user) {
                value += user
              }

              if (no) {
                value += "#" + no
              } else {
                value += "@"
                nodes.push({ type: "inlineCode", value: abbr(hash) })
              }

              nodes.unshift({ type: "text", value })

              return { type: "link", title: null, url, children: nodes }
            }
          }
        },
      ]
    },
  }
}

/**
 * Abbreviate a SHA.
 *
 * @param {string} sha
 *   SHA.
 * @returns {string}
 *   Abbreivated SHA.
 */
function abbr(sha: string): string {
  return sha.slice(0, minShaLength)
}

/**
 * Parse a link and determine whether it links to GitHub.
 */
function parse(node: Link): UrlInfo | undefined {
  const match = linkRegex.exec(node.url)

  if (
    // Not a proper URL.
    !match ||
    // Looks like formatting.
    node.children.length !== 1 ||
    node.children[0].type !== "text" ||
    toString(node) !== node.url ||
    // SHAs can be min 4, max 40 characters.
    (match[3] === "commit" && (match[4].length < 4 || match[4].length > 40)) ||
    // SHAs can be min 4, max 40 characters.
    (match[3] === "compare" && !/^[a-f\d]{4,40}\.{3}[a-f\d]{4,40}$/.test(match[4])) ||
    // Issues / PRs are decimal only.
    ((match[3] === "issues" || match[3] === "pull") && /[a-f]/i.test(match[4])) ||
    // Projects can be at most 99 characters.
    match[2].length >= 100
  ) {
    return
  }

  let reference = match[4]

  if (match[3] === "compare") {
    const [base, compare] = reference.split("...")
    reference = abbr(base) + "..." + abbr(compare)
  } else {
    reference = abbr(reference)
  }

  return {
    comment: node.url.charAt(match[0].length) === "#" && match[0].length + 1 < node.url.length,
    page: match[3],
    project: match[2],
    reference,
    user: match[1],
  }
}
